<html>
<head>
<meta charset="UTF-8">
<title>Stream Status Checker</title>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" type="text/javascript"></script>
<!-- https://github.com/carhartl/jquery-cookie -->
<script src="jquery.cookie.js"></script>
<!-- http://jscolor.com/ -->
<script src="jscolor.js"></script>


<style>
:root {
	--live-color: #008000;
	--offline-color: #FF0000;
	--info-color: #FFA500
	--rerun-color: #999900
}

.box {
	display: inline-block;
	height: 62px;
	width: 181px;
	margin: 0;
	border-bottom: 1px solid #000;
	border-right: 1px solid #000;
	overflow-x: hidden;
	overflow-y: auto;
	vertical-align: top;
	font-size: 14px;
	line-height: 100%;
	box-sizing: border-box;
	
}

.list {
	height: 21px;
	border-bottom: 1px solid #000;
	box-sizing: border-box;
	white-space: nowrap;
	overflow: hidden;
}

#streamArea { margin: 0; }
body { margin: 0; }

.controls {
	width: 100%;
	margin: 0;
	padding: 0;
	white-space: nowrap;
	display: flex;
}

#controls_top {
	margin-bottom: 2px;
}

#controls_bottom {
	margin-top: 2px;
}

.showOptions, .swap, .insert {
	border: 1px solid #000;
	width: 50%;
	text-align: center;
	padding: 0;
	box-sizing: border-box;
}

.swap, .insert {
	width: 25%;
}

#options {
	display: none;
	position: fixed;
	width: 50vw;
	height: 50vh;
	top: 15vh;
	left: 25vw;
	max-width: 550px;
    min-width: 325px;
	height: 175px;
	border: 1px solid #000;
	background-color: #999999;
  z-index: 10;
}

@media screen and (max-width: 600px){
	#options {
		left: 15vw;
	}
}

#closeOpX {
	position: relative;
	float: right;
	border: 0 0 0 3;
	height: 18px;
	width: 18px;
	text-align: center;
	border-left: 1px solid #000;
	border-bottom: 1px solid #000;
  opacity: 1;
}

#optionsList, #colorsList {
	display: flex;
	flex-flow: row wrap;
}

.anOption {
	border: 1px solid #000;
	width: 48%;
	margin: 2px;
}

.colorLabel {
	margin: 0 2px;
	width: 30%;
}

.colorInput {
	margin: 0 2px;
	width: 40%;
}

.colorInput input {
	width: 125px;
}

.colorReset {
	margin: 0 2px;
	border: 1px solid #000;
	width: 15%;
	right: 0;
}

#overlay {
  z-index: 2;
  display: none;
  background: #000;
  opacity: 0.6;
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
} 

.horizLabel {
	text-align: center;
	z-index: 5;
	font-size: 12px;
}

.horizLabel::before{
	border-top: 1px solid #000;
	content: "";
	margin: 0 auto;
	margin-top: 5px;
	position: absolute;
	left: 11;
	z-index: -1;
	width: 95%;
}

.horizLabel span{
	background: #999999;
	padding-left: 6px;
	padding-right: 6px;
}


#swapExplanation, #insertExplanation { display: none; } 
#disablePushB, #testPushB { display: none; }
#delPBdiv { display: none; }
.swap1, .insert1 { border: 1px solid #ADD8E6; }

.disabledText {
	background: #666;
	color: #CCC;
	border: 1px solid #333;
}
.favicon { float: left; }
#dropdownIcon { display: inline-block; height: 14px; }
.nowrap { display: inline-block; white-space: nowrap; }

.live { background-color: var(--live-color); }
.offline { background-color: var(--offline-color); }
.rerun { background-color: var(--rerun-color); }
.info { background-color: var(--info-color); }
body { background-color: #999999; }

</style>
</head>
<body>
<script type="text/javascript">
var watchedStreams = [ ];
var listMode = false;
var host = "//" + window.location.host;
var favicons = true;
var sorting = false;
var jqXHRGlobal = "";
var streamColor = [ ];
var defaultColor = {"info": "FFA500", 
	"live": "008000", "rerun": "999900",
	"offline": "FF0000" };

//Creates an object out of stream, site, and ID
function streamObj(stream, site, streamID) {
	this.stream = stream;
	this.site = site;
	//If no stream ID given, default to empty quotes
	this.streamID = (typeof streamID !== 'undefined' ? streamID : "");
	//WIP: Used to send out some sort of alert when stream goes live.
	//Set everything to true by default so the initial load doesn't explode in alerts.
	this.wasLive = true;
}

//Returns a streamObj's information as stream:id-site
streamObj.prototype.toString = function streamString() {
	var strRet = this.stream;
	if( this.streamID != "" ){ strRet = strRet + ":" + this.streamID; }
	strRet = strRet + "-" + this.site;
	return strRet;
}

//Removes all status classes from a div and sets it to current status.
function setLiveStatus(divID, status) {
    $(divID).removeClass("info");
    $(divID).removeClass("live");
    $(divID).removeClass("rerun");
    $(divID).removeClass("offline");
    
    $(divID).addClass(status);
}

//Takes a string representing both stream and site and breaks it into its
//  two respective parts, denoted by the final dash.
function streamFromString(toSplit) {
    var site = toSplit.slice(-3);
	toSplit = toSplit.slice(0,-4);
    
    var streamID = "";
	if( toSplit.indexOf(":") > 0 ){
		streamID = toSplit.split(":")[1];
		toSplit = toSplit.split(":")[0];
	}
    
	var stream = toSplit;
    
    return new streamObj(stream, site, streamID);
}

function processCookies(){
	//Loads the saved stream cookie as string, re-saves it to update expiration, and turns into array.
	if($.cookie("watchedStreams")){
		var theCookie = $.cookie("watchedStreams").replace("%3B",";")
		theCookie = theCookie.replace("%3A",":");
		$.cookie("watchedStreams",theCookie, { expires: 30 });
		
		watchedStreams = theCookie.split(";");
	}
	
	if($.cookie("listMode")){
		//If a cookie exists named "listMode", set the variable "listMode"
		//	Forces the string to be converted into a boolean.
		listMode = ($.cookie("listMode") == "true");
		$.cookie("listMode", listMode, { expires: 30 });
	}
	
	if($.cookie("favicons")){
		//If a cookie exists named "favicons", set the variable "favicons"
		//	Toggles whether stream site is shown via favicon or in parentheses.
		favicons = ($.cookie("favicons") == "true");
		$.cookie("favicons", favicons, { expires: 30 });
	}
    
    if($.cookie("sorting")){
		//If a cookie exists named "sorting", set the variable "sorting"
		//	Toggles whether live streams are sorted to the top.
		sorting = ($.cookie("sorting") == "true");
		$.cookie("sorting", sorting, { expires: 30 });
	}
	
	if($.cookie("colors")){
		var theColors = {};
		theColors = $.cookie("colors").split(";");
		console.log("cookie: " + theColors);

		for(var k in theColors){
			var status = theColors[k].split(":")[0];
			var color = theColors[k].split(":")[1];
			
			streamColor[status] = color;
			
			$("#"+status+"Color").val(color);
			$("#"+status+"Color").css("background","#"+color);
		
			status = "--"+status+"-color";
			document.documentElement.style.setProperty(status,"#"+color);
			
			saveColors();
		}
	} else {
		streamColor = defaultColor;
	}
	
	//Loads each div from the array
	$.each(watchedStreams, function(num, val) {
		//Converts each entry into an object
		var newObject = streamFromString(val);
        
        //Hitbox changed to Smashcast, everything else should be same, so just change site
        if (newObject.site == "hbx"){
            newObject.site = "sma";
        }
        
        //Beam changed to Mixer, everything else should be same, so just change site
        if (newObject.site == "bea"){
            newObject.site = "mxr";
        }
            
		watchedStreams[num] = newObject;
		
		var stream = newObject.stream;
		var site = newObject.site;
		var streamID = newObject.streamID;
        
		//Adds div to stream area
		$("#streamArea").append("<div id=" + num + " class='info stream'>Getting " + stream + "'s Info ...</div>");
		var newDivID = "#" + num;
		
		//Sets class to either list or box based on saved display mode
		var type = ((listMode) ? "list" : "box");
		$(newDivID).addClass(type);

		setLiveStatus(newDivID, "info");
	});
}

//Return a simple div of either site favicon or (site) based on favicon setting
function getFavicon(site) {
    site = site.toLowerCase();
	if(favicons) {
		return "<div class='favicon' title='" + site + "'><img width='14' height='14' src='" + host + "/style/" + site + ".ico' alt='(" + site + ")' /></div>";
	} else {
		return "<div class='favicon' title='"+site+"'>(" + site + ")</div>"
	}
}

//Process clicking on the div to toggle favicons
function toggleFavicons() {
	favicons = !favicons;  //Invert variable
	$("#faviconCheck").prop("checked", favicons); 		//Set checkbox to be the same as favicon variable.
	$(".favicon").each(function(){						//Go through each "favicon" class div, redo the
		$(this).html(getFavicon($(this).attr("title")));//   call with site based on div's "title" property
	});
	
	$.cookie("favicons", favicons, { expires: 30 });    //Set cookie so favicon setting persists
}

//Makes popup of the stream when it's double-clicked
function makePopup(stream) {
    var width = 640;
    var height = 360;
    var left = (window.screenX != 'undefined' ? window.screenX : window.screenLeft) - 50;
    var top = (window.screenY != 'undefined' ? window.screenY : window.screenTop) + 200;
	var windowFeatures = ",menubar=no,toolbar=no,scrollbars=no,resizable=yes," +
            "left=" + left + ",top=" + top + "screenX=" + left + ",screenY=" + top;

	windowFeatures = "width=" + width + ",height=" + height + windowFeatures;
	window.open(host + "/ls.php?s="+stream, stream.split(",")[0], windowFeatures);
}

//Make API calls to check if stream's live
function checkStream(toCheck){
	var tempObj = watchedStreams[toCheck];
	var stream = tempObj.stream;
	var site = tempObj.site;
	
    var statusCodeHandler = {
            //  400: function(a, b, c) { console.log("400 detected."); requestError(a, b, c, toCheck); },
				502: function(a, b, c) { console.log("502 on " + stream + " (" + site + ")"); requestError(a, b, c, toCheck); },
				503: function(a, b, c) { console.log("503 on " + stream + " (" + site + ")"); requestError(a, b, c, toCheck); },
                504: function(a, b, c) { console.log("504 on " + stream + " (" + site + ")"); requestError(a, b, c, toCheck); }
			};
	
	var errorHandler = function(a, b, c){ requestError(a, b, c, toCheck); };
	
	if(site == "ttv"){
        var streamID = tempObj.streamID;
        if( streamID == "undefined" || streamID == ""){
//          console.log("Twitch stream without ID, requesting instead of checking");
            getTwitchID(stream, toCheck);
            return;
        }
        
		return $.ajax({
            type: 'GET',
			url: 'https://api.twitch.tv/kraken/streams/'+streamID,
			timeout: 10000,
            headers: {"Client-ID": "glrjuvya5xmg8batkujqtfij53q073h",
                       "Accept": "application/vnd.twitchtv.v5+json"},            
			success: function(data) { handleTwitch(data, toCheck); },
			error: errorHandler,
			statusCode: statusCodeHandler
		});
	
	//UStream API request
	} else if(site == "utv"){
        var streamID = tempObj.streamID;
		return $.ajax({
            type: 'GET',
			//url: 'http://einsynd.pw/ustreamAPI.php?stream=' + streamID,
            url: "//api.ustream.tv/channels/" + streamID + ".json",
			timeout: 10000,
			success: function(data) { handleUStream(data, toCheck); },
			error: errorHandler,
			statusCode: statusCodeHandler
		});	

	//Smashcast API request (Formerly Hitbox)
    //  Smashcast currently doesn't allow cross-domain requests. Just keep Hitbox's.
	} else if(site == "sma"){
		return $.ajax({
			type: 'GET',
            url: '//www.hitbox.tv/api/media/live/'+stream+'?nocache=true',
			timeout: 10000,
			success: function(data) { handleSmashcast(data, toCheck); },
			error: errorHandler,
			statusCode: statusCodeHandler
		});
    //Livestream API request
	} else if(site == "lst"){
		return $.ajax({
			url: 'http://x' + stream + 'x.api.channel.livestream.com/2.0/info.json',
			dataType: 'jsonp',
			timeout: 7500,
			success: function(data) { handleLivestream(data, toCheck); },
			error: errorHandler,
			statusCode: statusCodeHandler
		});
    //Mixer API request (Formerly Beam)
    } else if(site == "mxr"){
        return $.ajax({
            url: 'https://mixer.com/api/v1/channels/' + stream,
            timeout: 10000,
            success: function(data) { handleMixer(data, toCheck); },
			error: errorHandler,
			statusCode: statusCodeHandler
        });
	} else if(site == "jtv"){
		$("#"+toCheck).html(getFavicon(site) + stream + ": Justin.TV has closed.").addclass("offline");
	} else {
		alert("Not supported: site="+site);
	}
}

//Set div for handled Twitch stream.
function handleTwitch(data, toCheck) {
	var divID = "#" + toCheck;

	var tempObj = watchedStreams[toCheck];
	var stream = tempObj.stream;
	var site = tempObj.site;
    var streamID = tempObj.streamID;
    
	var wasLive = tempObj.wasLive;
	var lastStatus = "undefined";
    
	if(tempObj.lastStatus != null) {
		lastStatus = tempObj.lastStatus;
	}
	var nowrap = "<div class='nowrap'>";
	
	if(typeof data.error !== "undefined"){
		if( data.error == "Service Unavailable" ){
			$(divID).html(nowrap + getFavicon(site) + stream + "</div>: Twitch returned error 503, Service Temporarily Unavailable");
		} else if( data.error == "Not Found" ) {
			$(divID).html(nowrap + getFavicon(site) + stream + "</div>: Channel not found, possibly deleted by owner.");
		} else {
			console.log("Unhandled error: '"+ data.error + "' on #" + toCheck);
		}
        setLiveStatus(divID, "info");
	} else {
		if( data.stream != null){
			//If there's a "stream" variable, the stream is live
			data = data.stream;
			if( data.channel.status == null ) {
				//Twitch keeps sending a shorter API response without the stream title
				//If we have a saved status from the previous call, just use that, otherwise re-request.
				if( lastStatus == "undefined" ){
					//Wait half a second to re-check so it's less spammy.
					setTimeout(function(){
						console.log("Status description wasn't sent, re-requesting " + stream + "...");
						checkStream(toCheck);
						}, 500);
					return;
				} else {
					console.log("Status description wasn't sent, going with saved status for " + stream);
					data.channel.status = lastStatus;
				}
			}
			//Save the current status in case next check screws up.
			watchedStreams[toCheck].lastStatus = data.channel.status;
			
			var link = "<a href='"+data.channel.url+"' target='_blank'>";
            var game = (data.game != null) ? " - " + data.game : "";
			$(divID).html(nowrap + getFavicon(site) + link + stream + "</a></div> [" + data.viewers + "v]: " + data.channel.status + game);
            if( data.stream_type == "live"){
                setLiveStatus(divID, "live");
            } else {
                setLiveStatus(divID, "rerun");
            }
            
            game = (data.game != null) ? " [" + data.game + "]" : "";
			$(divID).prop("title",data.channel.status + game + " -- " + data.viewers + " viewers.");
            
			if( wasLive == false ){
				watchedStreams[toCheck].wasLive = true;
				sendAlert(stream, site, data.channel.status);
			}
            
            sortLiveStreams();
            
		} else {
			//It didn't find a "stream" variable, so it must be offline.
			$(divID).html(getFavicon(site) + stream + ": Offline").addClass("offline");
			$(divID).prop("title","");
            setLiveStatus(divID, "offline");
			if( wasLive ) {
				watchedStreams[toCheck].wasLive = false;
			}
		}
	}
}

//Set div for handled Livestream streams
function handleLivestream(data, toCheck) {
	var divID = "#" + toCheck;

	var tempObj = watchedStreams[toCheck];
	var stream = tempObj.stream;
	var site = tempObj.site;
	var wasLive = tempObj.wasLive;
	
	if(data.channel.isLive == true){
		$(divID).html(getFavicon(site) + stream + "[" + data.channel.currentViewerCount + "v] is live!" )
        setLiveStatus(divID, "live");
        
		if( wasLive == false ){
			watchedStreams[toCheck].wasLive = true;
			sendAlert(stream, site, "is now live!");
		}
	} else {
		$(divID).html(getFavicon(site) + stream + ": Offline")
        setLiveStatus(divID, "offline");
        
		if( wasLive ) {
			watchedStreams[toCheck].wasLive = false;
		}
	}
}

//Set div for handled UStream streams
function handleUStream(data, toCheck) {
	var divID = "#" + toCheck;

	var tempObj = watchedStreams[toCheck];
	var stream = tempObj.stream;
	var site = tempObj.site;
	if( tempObj.streamID == "" ){
		tempObj.streamID = data.id;
		watchedStreams[toCheck] = tempObj;
	}
	var wasLive = tempObj.wasLive;

	if(data.channel.status == "live"){
		$(divID).html(getFavicon(site) + stream + " is live!" );
        setLiveStatus(divID, "live");
        
		if( wasLive == false ){
			watchedStreams[toCheck].wasLive = true;
			sendAlert(stream, site, "is now live!");
		}
        sortLiveStreams();
        
	} else {
		$(divID).html(getFavicon(site) + stream + ": Offline");
        setLiveStatus(divID, "offline");
        
		if( wasLive ) {
			watchedStreams[toCheck].wasLive = false;
		}
	}
}

//Set div for handled Smashcast stream.
function handleSmashcast(data, toCheck) {
	var divID = "#" + toCheck;
	var tempObj = watchedStreams[toCheck];
	var stream = tempObj.stream;
	var site = tempObj.site;
	var wasLive = tempObj.wasLive;
	
	// Initially had to handle offline separately since it returned a string instead of an array,
	// but it looks like they've fixed that now. Check for "media_is_live".
	if( data.livestream == null ) { 
		if( data.error == true ){
            if( data.error_msg == "no_media_found" ){
                $(divID).html(getFavicon(site) + stream + " does not exist");
            } else {
                $(divID).html(getFavicon(site) + stream + ": " + data["error_msg"]);
            }
		}
	} else if( data.media_type == "live" && data.livestream[0].media_is_live == "1"){
		data = data.livestream[0];
		link = "<a href='"+data.channel.channel_link+"' target='_blank'>";
		$(divID).html(getFavicon(site) + link + stream + "</a>[" + data.media_views + "v]: " + data.media_status + ((data.category_name != null) ? " - " + data.category_name : ""));
		$(divID).prop("title",data.media_status + ((data.category_name != null) ? " - " + data.category_name : "") + " -- " + data.media_views + " viewers.");
        setLiveStatus(divID, "live");
        
		if( wasLive == false ){
			watchedStreams[toCheck].wasLive = true;
			sendAlert(stream, site, data.media_status + ((data.category_name != null) ? " - " + data.category_name : ""));
		}
	} else {
		$(divID).html(getFavicon(site) + stream + ": Offline");
		$(divID).prop("title","");
        setLiveStatus(divID, "offline");
		if( wasLive ) {
			watchedStreams[toCheck].wasLive = false;
		}
	}
}

//Set div for handled Mixer stream.
function handleMixer(data, toCheck){
//  console.log(data);
    var divID = "#" + toCheck;
	var tempObj = watchedStreams[toCheck];
	var stream = tempObj.stream;
	var site = tempObj.site;
	var wasLive = tempObj.wasLive;
    
    if( data.online == true) {
        var link = "<a href='//mixer.com/" + stream + "' target='_blank'>";
        var game = (data.type != null) ? " - " + data.type.name : "";
        $(divID).html(getFavicon(site) + link + stream + "</a> [" + data.viewersCurrent + "v]: " + data.name + game);
        setLiveStatus(divID, "live");
        
        game = (data.type != null) ? " [" + data.type.name + "]" : "";
        $(divID).prop("title",data.name + game + " -- " + data.viewersCurrent + " viewers.");
    } else {
        $(divID).html(getFavicon(site) + stream + ": Offline");
        setLiveStatus(divID, "offline");
    }
}

//Handle errors that are thrown in a bit of a generic error.
function requestError(jqXHR, textStatus, errorThrown, toCheck){
	var divID = "#" + toCheck;

	var tempObj = watchedStreams[toCheck];
	var stream = tempObj.stream;
	var site = tempObj.site;
	
	console.log( stream + ": " + ((textStatus !== undefined) ? textStatus : "_") + "|" + ((errorThrown !== undefined) ? errorThrown : "_") );
//	console.log(jqXHR);
	
	//Handles errors from the AJAX requests.
	//	Apparently the only error JSONP can throw is Timeout, so. Bluh.
	if (typeof textStatus === "string"){
        
		if (textStatus == "timeout"){
			$(divID).html(getFavicon(site) + stream + " timed out.");
			setLiveStatus(divID, "info");
            
		} else if (errorThrown == "Service Unavailable") {
            $(divID).html(getFavicon(site) + stream + ": Unknown (Service Unavailable)");
            setLiveStatus(divID, "info");
        } else if (errorThrown == "Bad Request"){
            if (site == "ttv") {
                $(divID).html(getFavicon(site) + stream + ": Unknown (Bad Request - Twitch ignored Client ID)");
            } else {
                $(divID).html(getFavicon(site) + stream + ": Unknown (Bad Request)");
            }
            setLiveStatus(divID, "info");
        } else if( errorThrown == "Unprocessable Entity" ) {
            $(divID).html(getFavicon(site) + stream + "</div>: Channel has been closed for TOS violations");
        } else if( errorThrown == ""){
            //Some sort of error, probably cross-domain but no way of knowing
            $(divID).html(getFavicon(site) + stream + "</div>: Error Requesting Info");
        } else if( errorThrown == "Not Found") {
            $(divID).html(getFavicon(site) + stream + " does not exist");
        } else {
            console.log(textStatus + ": " + errorThrown);            
        }
	} else {
		//If somehow an error was thrown that wasn't a string?
		$(divID).html(getFavicon(site) + stream + ": Offline");
		$(divID).prop("title","");
        setLiveStatus(divID, "offline");
        
		console.log("Request Error: "+textStatus);
	}
}

//Quick function to foreach an error for all Twitch streams since they'll all be the same error
function handleMassError(jqXHR, textStatus, errorThrown, twitchStreams){
    $.each(twitchStreams, function(index,stream){
        requestError(jqXHR, textStatus, errorThrown, stream.divID);
    });    
}

//Sends a single API hit for all checked Twitch streams' statuses.
function twitchCheck(twitchIDList, twitchStreams){
    var statusCodeHandler = {
    //  400: function(a, b, c) { console.log("400 detected."); requestError(a, b, c, toCheck); },
        500: function(a, b, c) { console.log("500 on mass Twitch"); handleMassError(a, b, c, twitchStreams); },
        502: function(a, b, c) { console.log("502 on mass Twitch"); handleMassError(a, b, c, twitchStreams); },
        503: function(a, b, c) { console.log("503 on mass Twitch"); handleMassError(a, b, c, twitchStreams); },
        504: function(a, b, c) { console.log("504 on mass Twitch"); handleMassError(a, b, c, twitchStreams); }
    };
	
	var errorHandler = function(a, b, c){ handleMassError(a, b, c, twitchStreams); };

    return $.ajax({
        type: 'GET',
        url: 'https://api.twitch.tv/kraken/streams?limit=100&channel='+twitchIDList,
        timeout: 10000,
        headers: {"Client-ID": "glrjuvya5xmg8batkujqtfij53q073h",
                   "Accept": "application/vnd.twitchtv.v5+json"},            
        success: function(data) { handleMassTwitch(data, twitchStreams); },
        error: errorHandler,
        statusCode: statusCodeHandler
    });    
}

//Handles the return from the API request
function handleMassTwitch(data, twitchStreams){
    
    var nowrap = "<div class='nowrap'>";
    var favicon = getFavicon("ttv");
    data = data.streams;
    
    //Foreach through the returned live streams
    $.each(data, function(index,response){
        var twitchID = response.channel._id;
        var twitchName = response.channel.name;
        var twitchDispName = response.channel.display_name;
        var twitchType = response.stream_type;
        var thisStream = twitchStreams[twitchID];
        
        //API reports a different stream name belonging to a checked stream ID, so update.
        if( twitchName !== thisStream.name.toLowerCase() ){
            if( twitchName == twitchDispName.toLowerCase() ){
                thisStream.name = twitchDispName;
            } else {
                thisStream.name = twitchName;
            }
        }

        var link = "<a href='"+response.channel.url+"' target='_blank'>";
        var game = (response.game != null) ? " - " + response.game : "";
        thisStream.status = nowrap + favicon + link + thisStream.name + "</a></div> [" + response.viewers + "v]: " + response.channel.status + game;
        
        //Change the "game" to fit better for a tooltip
        game = (response.game != null) ? " [" + response.game + "]" : "";
        thisStream.tooltip = response.channel.status + game + " -- " + response.viewers + " viewers.";
        thisStream.liveType = twitchType;
    });
    
    //Foreach through all of the Twitch streams
    $.each(twitchStreams, function(index,twitch){
        divID = "#" + twitch.divID;
        //If it wasn't live, its status should still be "Offline"
        if( twitch.status === "Offline") {
            $(divID).html(favicon + twitch.name + ": Offline");
			$(divID).prop("title","");
            setLiveStatus(divID, "offline");
        } else {
            $(divID).html(twitch.status);
            $(divID).prop("title",twitch.tooltip);
            if( twitch.liveType == "live" ) {
                setLiveStatus(divID, "live");
            } else {
                setLiveStatus(divID, "rerun");
            }
        }
        
        //If streamer changed name, ID will be the same but channel won't. Update from live check.
        if(watchedStreams[twitch.divID].stream.toLowerCase() != twitch.name.toLowerCase()){
            watchedStreams[twitch.divID].stream = twitch.name;
            $.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
            
            console.log("Stream name changed, upating: " + twitch.name);
        }
    });
    sortLiveStreams();
}

//WIP: Sends alert when stream is live.
function sendAlert(stream, site, status){
	//If the Disable PushBullet button is visible, then PushBullet should be enabled, so alert with it.
	if($("#disablePushB").is(":visible")){
		if( site != 'einSynd.pw' ) { site = site.toUpperCase(); }
		title = stream + " is live on " + site + ":";
		body = status;
		toSend = {'token': $("#accessToken").val(), 'device': $("#deviceID").val(), 'title': title, 'body': body};
		$.ajax({
			url: '//einsynd.pw/pushBullet.php',
			type: 'POST',
			data: toSend,
			error: function(a,b,c) { console.log(b + ": " + c); }
		});			
	}
}

//Adds a new stream from given info.
//Used to be part of requestCheck. Not sure why.
function addStream() {
    var streamNum;
    
    stream = $('#checkStream').val();
    if( stream == "" ){
        return false;
    }
    var site = $('#site').val();
    var exists = false;
    
    //Check each stream div (.stream) to see if it already exists.
    $.each(watchedStreams, function(num, obj) {
        if( obj.stream == stream ){
            if( obj.site == site ) {
                exists = true;
                return false;
            }
        }
    });
    
    //If exists, tell user. Otherwise, make a new div.
    if( exists ) {
        alert("This stream is already being checked for.");
        console.log("Already checked: '" + stream + "' on " + site);
    } else {
        //Length returns total number, divs start at zero, so length should be one above what we have.
        var newDivID = $(".stream").length;
        
        $("#streamArea").append("<div id='" + newDivID + "'>Getting " + getFavicon(site) + stream + "'s Info ...</div>");			
        newDivID = "#" + newDivID;
        $(newDivID).addClass("stream")
        
        //If there are things with class "list" then add "list" class, otherwise default to "box" class
        var type = (($(".list").length > 0) ? "list" : "box");
        $(newDivID).addClass(type);
        
        //Creates an object with the div's info.
        var divObj = new streamObj(stream, site);
        
        setLiveStatus(newDivID, "info");
        
        watchedStreams.push(divObj);
        $.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
    }
    
    //Set "streamNum" to the name of the div's ID so it matches a normal call.
    streamNum = newDivID.slice(1);
    
    //Check for UStream/Twitch, get ID instead of checking instead.
    if(site == "utv"){
        getUstreamID(stream, streamNum);
        return;
    } else if(site == "ttv"){
        getTwitchID(stream, streamNum);
        return;
    }
    
    requestCheck(streamNum)
}

//Request checks for non-Twitch streams while putting all Twitch streams
//into an array to check all at once.
function prepareCheck(){
    var twitchStreams = { };
    var twitchIDs = [ ];
    var twitchIDList;
    
    $(".stream").each(function(i) {
        var curID = $(this).prop("id");
        //For each type of div with class "info", request a check.
        if (typeof watchedStreams[curID] !== "undefined"){
            //Change the words to let you know it's checking, then actually check.
            $(this).html("Getting " + getFavicon(watchedStreams[curID].site) + watchedStreams[curID].stream + "'s Info ...");
            
            if( watchedStreams[curID].site == "ttv") {
                //Twitch stream, add to temp array and set all status to offline,
                //which will be overwritten if a check is found successful
                var index = watchedStreams[curID].streamID;
                twitchStreams[index] = {
                    divID: curID,
                    name: watchedStreams[curID].stream,
                    status: "Offline",
                    tooltip: ""
                };

                twitchIDs.push(watchedStreams[curID].streamID);
                //Max Twitch multi-request is 100, so if we somehow have that many,
                //go ahead and check and empty the variables.
                if( twitchIDs.length > 99 ){
                    twitchIDList = twitchIDs.join(",");
                    twitchCheck(twitchIDList, twitchStreams);
                    
                    twitchIDs = [ ];
                    twitchStreams = { };
                }
            } else {
                requestCheck(curID);
            }
        }
    });
    
    twitchIDList = twitchIDs.join(",");
    twitchCheck(twitchIDList, twitchStreams);
}

//Performs minor maintenance before directly checking for a stream.
function requestCheck(streamNum){
	//Check if it's old Livestream format and convert to new.
	//	That being, add a T on the end. (ls -> lst)
	if(watchedStreams[streamNum] == "ls"){
		console.log("Old Livestream format detected, converting ... (" + watchedStreams[streamNum].stream +")");
		watchedStreams[streamNum].site = "lst";
		$.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
	}
	
	checkStream(streamNum);
}

//Twitch API requires ID as of v5. Luckily they eventually added an API to find it.
function getTwitchID(stream, streamNum){
    var tempObj = watchedStreams[streamNum];
    
    $.ajax({
        url: 'https://api.twitch.tv/kraken/users?login=' + stream.toLowerCase(),
        headers: {"Client-ID": "glrjuvya5xmg8batkujqtfij53q073h",
                  "Accept": "application/vnd.twitchtv.v5+json"}, 
        type: "get",
        timeout: 10000,
        success: function(data){
            //Good news, it returns properly if there were no results.
            if( data["_total"] === 0 ){
                console.log("Twitch ID success, doesn't exist. stream: " + stream + ", div number " + streamNum);
                alert("Twitch stream " + stream + " does not exist");
                removeStreamNum(streamNum);
            } else {
                data = data["users"][0]["_id"];
                tempObj.streamID = data;
                watchedStreams[streamNum] = tempObj;
                checkStream(streamNum);
                //Save the cookie on ID retrieval, so that things update to the new
                //format properly. Prevents issues.
                $.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
            }
        },
        error: function(){
            //Since there's a legit way to tell if there's no stream with that name,
            //an error doesn't necessarily mean the stream doesn't exist.
            console.log("Twitch ID error, stream: " + stream + ", div number " + streamNum);
            alert("Error retrieving Twitch ID, will try again soon");
        },
    })
}

//UStream removed easy access to ID, so now I have to fetch it.
function getUstreamID(stream, streamNum){
    var tempObj = watchedStreams[streamNum];

    $.ajax({
        url: '//einsynd.pw/ustreamID.php?stream=' + stream,
        dataType: "jsonp",
        jsonp: "callback",
        success: function(data){
            data = data["id"];
            console.log("Success, ID: " + data);
            tempObj.streamID = data;
            watchedStreams[streamNum] = tempObj;
            checkStream(streamNum);
            $.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
        },
        error: function(){
            console.log("UStream ID error, stream: "+ stream + ", div number " + streamNum);
            alert("Stream does not exist");
            removeStreamNum(streamNum);
        },
        type: "get",
        timeout: 10000
    });
}

//Removes stream div from the page automatically via div number
function removeStreamNum(streamNum){
    $("#"+streamNum).remove();
    
    //Removes the entry in the stream array
    watchedStreams.splice(streamNum, 1);
    
    //Renumbers the divs so there aren't any holes
    $.each($(".stream"), function(num) {
        $(this).prop("id", num);
    });
    
    //Set the cookie so it stays gone.
    $.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
}

//Removes stream div from the page via page's form
function removeStream(){
	var stream = $('#checkStream').val();
	var site = $('#site').val();
	var removed = -1;
	
	//Loop through the watchedStreams array to check for matching info
	$.each(watchedStreams, function(id,obj) {
		var curStream = obj.stream;
		var curSite = obj.site;
		
		if( curStream.toLowerCase() == stream.toLowerCase() ){
			if( curSite.toLowerCase() == site.toLowerCase() ){
				//	console.log("Matched at #" + id);
				$("#"+id).remove();
				watchedStreams.splice(id, 1);
				removed = id;
				return false;			
			}
		} 
	});
	
	//If a stream was removed, re-order the divs and set the cookie
	if( removed != -1 ) {
		//Loop over the divs after the one removed and subtract their ID by one to properly match array
		for(var i = removed + 1; i <= watchedStreams.length; i++){
			$("#"+i).attr("id", i - 1);
		}

		//Set the cookie so it stays gone.
		$.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
	} else {
		console.log("No stream found to remove: '" + stream + "' on " + site);
	}
}

//Allow swapping of streams
//	Click two streams to swap the two
function swapMode() {
	if( $(".stream").length <= 1 ) {
		return
	}
	//If class "swappable" isn't on anything, turn on edit mode, else turn off.
	if( $(".swappable").length <= 0 ){
		//Ignore it if they're already in insert mode
		if( $(".insertable").length > 0 ){
			return
		}
		
		//Add class "swappable" so we know they can do things.
		$(".stream").addClass("swappable");
		$("#swapExplanation").show();
		$(".insert").addClass("disabledText");
		
		
		//Bind a click event to all swappable divs
		$(".swappable").on("click.swapping", function(b){
			//Only fire on mouse1
			if( b.which == 1 ){
				//If there's not already a selected div (class "swap1") then set this to "swap1"
				//	else, swap the clicked div with that one
				
				if( $(".swap1").length <= 0 ){
					$(this).addClass("swap1"); //CSS makes it 1px white border for attention
				} else {
					//Get the ID of first-clicked div and this div
					var id1 = $(".swap1").prop("id");
					var id2 = $(this).prop("id");
					//If they're the same, ignore it, something probably just went screwy.
					if( id1 != id2 ){
			
						//Clone the divs, then replace them
						var clone1 = $("#"+id1).clone(true).prop("id", id2);
						var clone2 = $("#"+id2).clone(true).prop("id", id1);
						
						$("#"+id1).prop("id","s1");
						$("#"+id2).prop("id","s2");
                        
						$("#s1").replaceWith(clone2);
						$("#s2").replaceWith(clone1);
                        
						//Swap in the arrays and save array to cookie
						var temp = watchedStreams[id1];
						watchedStreams[id1] = watchedStreams[id2];
						watchedStreams[id2] = temp;
						
						$.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
						
						//Remove ".swap1" from all divs with that class since a swap was made
						$(".swap1").removeClass("swap1");
					} else {
						//Clicked on same stream, maybe they don't want to sort
						$(".swap1").removeClass("swap1");
					}
					
				}
			}
		});
	} else {
		$(".swappable").unbind("click.swapping");
		$(".swappable").removeClass("swappable");
		$(".swap1").removeClass("swap1");
		$("#swapExplanation").hide();
		$(".insert").removeClass("disabledText");
	}
}

//Allow insertion sorting of streams
//	Click two streams, first stream gets put directly in front of second stream
function insertMode() {
	if( $(".stream").length <= 1 ) {
		return
	}
	//If class "insertable" isn't on anything, turn on edit mode, otherwise turn off
	if( $(".insertable").length <= 0 ){
		if( $(".swappable").length > 0 ){
			return
		}

		//Add class "insertable" so we know they can do things.
		$(".stream").addClass("insertable");
		$("#insertExplanation").show();
		$(".swap").addClass("disabledText");
		
		//Bind a click event to all swappable divs
		$(".insertable").on("click.inserting", function(b){
			//Only fire on mouse1
			if( b.which == 1 ){
				//If there's not already a selected div (class "insert1") then set this to "insert1"
				//	else, insert "insert1" before the clicked div
				
				if( $(".insert1").length <= 0 ){
					$(this).addClass("insert1"); //CSS makes it 1px white border for attention
				} else {
					//Get the ID of first-clicked div and this div
					var id1 = $(".insert1").prop("id");
					var id2 = $(this).prop("id");
					
					if( id1 < id2 ){
						for( var j = Number.parseInt(id1); j < id2-1; j++ ) {
							//Make copies of the two divs with swapped IDs
							var clone1 = $("#"+j).clone(true).prop("id", j+1);
							var clone2 = $("#"+(j+1)).clone(true).prop("id", j);
							
							//Set the IDs on the divs to mark them for swapping
							$("#"+j).prop("id","i1");
							$("#"+(j+1)).prop("id","i2");
							
							//Replace the divs with the updated clones
							$("#i1").replaceWith(clone2);
							$("#i2").replaceWith(clone1);
							
							//Swap the streams in the array for saving later
							var temp = watchedStreams[j+1];
							watchedStreams[j+1] = watchedStreams[j];
							watchedStreams[j] = temp;
						}

						if( sorting ){
							sortLiveStreams()
						}
						
						$.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });
						
						//Remove ".insert1" from all divs with that class since a swap was made
						$(".insert1").removeClass("insert1");
						
					} else if( id1 > id2 ){
						for( var j = Number.parseInt(id1); j > id2; j-- ) {
							//Make copies of the two divs with swapped IDs
							var clone1 = $("#"+j).clone(true).prop("id", j-1);
							var clone2 = $("#"+(j-1)).clone(true).prop("id", j);
							
							//Set the IDs on the divs to mark them for swapping
							$("#"+j).prop("id","i1");
							$("#"+(j-1)).prop("id","i2");
							
							//Replace the divs with the updated clones
							$("#i1").replaceWith(clone2);
							$("#i2").replaceWith(clone1);
							
							//Swap the streams in the array for saving later
							var temp = watchedStreams[j-1];
							watchedStreams[j-1] = watchedStreams[j];
							watchedStreams[j] = temp;
						}

						if( sorting ){
							sortLiveStreams();
						}
						
						$.cookie("watchedStreams",watchedStreams.join(";"), { expires: 30 });

						//Remove ".insert1" from all divs with that class since a swap was made
						$(".insert1").removeClass("insert1");
					} else {
						//Clicked on same stream, maybe they don't want to sort
						$(".insert1").removeClass("insert1");
					}
					
				}
			}
		});
	} else {
		$(".insertable").unbind("click.inserting");
		$(".insertable").removeClass("insertable");
		$(".insert1").removeClass("insert1");
		$("#insertExplanation").hide();
		$(".swap").removeClass("disabledText");
	}
}

//Check if stream list is sorted or not and do the opposite
function toggleSorting() {
    if( $("#sortLiveCheck").is(":disabled") && !$("#sortLiveCheck").is(":checked")) {
        return;
    }
    
	sorting = !sorting;  //Invert variable
	$("#sortLiveCheck").prop("checked", sorting);   //Set checkbox to be the same as sorting variable.
    if( sorting ){
        sortLiveStreams();
    } else {
        unsortLiveStreams();
    }
    
    if( !$("#sortLiveCheck").is(":disabled") ){
        $.cookie("sorting", sorting, { expires: 30 });  //Set cookie so sorting setting persists
    }
}

function streamSortFunc(i,j){
    var id1 = parseInt($(i).prop("id"));
    var id2 = parseInt($(j).prop("id"));
    return id1 - id2;
}

function sortLiveStreams() {
    if( $("#sortLiveCheck").is(":checked") ) {
        //Sort the streams and add them to the bottom of stream area in the order they should appear
        $("#streamArea .live").sort(streamSortFunc).appendTo($("#streamArea"));
        $("#streamArea .rerun").sort(streamSortFunc).appendTo($("#streamArea"));
        $("#streamArea .info").sort(streamSortFunc).appendTo($("#streamArea"));
        $("#streamArea .offline").sort(streamSortFunc).appendTo($("#streamArea"));    
    }
}

function unsortLiveStreams(){
    $.each($("#streamArea .stream"), function(a,b){
        $("#streamArea").append($("#"+a));
    });
}

function toggleList() {
	if( $(".box").length > 0 ){
		$(".box").addClass("list").removeClass("box");
		listMode = true;
	} else {
		$(".list").addClass("box").removeClass("list");
		listMode = false;
	}
	$("#listModeCheck").prop("checked", listMode);
	
	$.cookie("listMode", listMode, { expires: 30 });
}

function doubleClick(divID) {
	
	var tempID = $(divID).prop("id");
	var stream = watchedStreams[tempID].stream;
	var streamID = watchedStreams[tempID].streamID;
	var site = watchedStreams[tempID].site;
	
	if( site == "jtv" ){ return false; }
	
	if( streamID > 0 ){
		makePopup(stream + ":" + streamID + "," + site);
    } else {
		makePopup(stream + "," + site);
	}
}

function escClose(e){
	if(e.key == "Escape") {
		closeOptions();
	}
}

function closeOptions(){
  $("#overlay").hide();
	$("#options").hide();
	$(document).off("keydown", escClose);
}

function showOptions() {
  $("#overlay").show();
	$("#options").show();
	$(document).on("keydown", escClose)
}

function saveColors(){
	var streamString = "";
	
	for(var status in streamColor) {
		streamString += status + ":" + streamColor[status] + ";";
	}
	
	streamString = streamString.slice(0,-1);
	
	$.cookie("colors", streamString, { expires: 30 });
}

function colorUpdate(colorPicker){
	status = "--" + colorPicker.name + "-color";
	console.log(status);
	$("html").css(status,"#"+colorPicker.value);
	
	var root = document.querySelector('html');
	
	root.style.setProperty(status, "#"+colorPicker.value);
	streamColor[colorPicker.name] = colorPicker.value;
	saveColors();
}

function colorReset(status){
	console.log("reset "+status);
	color = "#" + defaultColor[status];
	$("#"+status+"Color").val(defaultColor[status]);
	$("#"+status+"Color").css("background",color);
	
	document.documentElement.style.setProperty("--"+status+"-color",color);
	streamColor[status] = defaultColor[status];
	saveColors();
}

$(document).ready(function(){
	//Load the cookie and process from there.
	processCookies();
	
	//Clicks to stream divs are sent to main streamArea div, which
	//	filters out double clicks to open popups for the clicked stream.
	$("#streamArea").on("dblclick", ".stream", function() { doubleClick(this); });
	
	$("#savePBdiv").on("click", function() { $("#savePB").click(); });
	$("#delPBdiv").on("click", function() { $("#delPB").click(); });
	
    prepareCheck();
	
	//Set dropdown change to trigger changing favicon next to it
	$("#site").change(function() {
		var selected = $("#site option:selected").val();
		$("#dropdownIcon").html(getFavicon(selected));
	});
    
	$("#faviconCheck").prop("checked", favicons); //Set the checkbox based on favicon variable
    $("#sortLiveCheck").prop("checked", sorting);
    
	$("#site").change(); //Auto-trigger it to set up the first one.
	
	//Set a timer to do automatic checks.
	setInterval(prepareCheck, 120000); //120,000 milliseconds = 120 seconds = 2 minutes.
    
    if( $("#sortLiveCheck").is(":checked") ){
        setTimeout(sortLiveStreams, 300);
    }
	
	//Don't actually do anything when the forms are used, just run scripts.
	$("form").submit(function(event) {
    event.preventDefault();
    event.stopPropagation();
    return false;
  });
});
</script>
<div id=controls_top class=controls>
	<div class=swap onclick="swapMode();">Swap</div>
	<div class=insert onclick="insertMode();">Insert</div>
	<div class=showOptions onclick="showOptions();">Options</div>
</div>
<div id=streamArea></div>
<div id=controls_bottom class=controls>
	<div class=swap onclick="swapMode();">Swap</div>
	<div class=insert onclick="insertMode();">Insert</div>
	<div class=showOptions onclick="showOptions();">Options</div>
</div>
<span id=swapExplanation>Click two streams to swap them. Click "Swap" to quit</span>
<span id=insertExplanation>Click a stream to move, then the stream to put it in front of. Click "Insert" to quit</span>
<br />
<form id="checkForm">
Enter a stream name and select a site to check its status:<br />(or to remove from the list above)<br />
<input type="text" name="checkStream" value="" id="checkStream" />
<select name="site" id="site">
	<option value="ttv" selected>Twitch.TV</option><option value="sma">Smashcast</option>
    <option value="mxr">Mixer</option>
	<option value="utv">UStream</option><option value="lst">Livestream</option>
</select><div id="dropdownIcon"></div><br />
<input type="submit" value="Check Status" name="submit" id="submit" onclick="addStream();" />
<input type="button" value="Remove From List" name="remove" id="remove" onclick="removeStream();" /> <br />
<br />
List of streams is saved in cookies.<br />

<strong>Double click</strong> the colored box to open a popup for the stream.<br />
If the description is too long, mouseover the box for a tooltip.<br />
<br />
</form>
<div id="overlay" onclick="closeOptions();"></div>
<div id="options">
<div id="closeOpX" onclick="closeOptions();">X</div>
<div id="optionsList">
<div class="anOption" onclick="toggleFavicons();"><input type="checkbox" name="favicons" id="faviconCheck"/>Show Favicons</div>
<div class="anOption" onclick="toggleSorting();"><input type="checkbox" name="sorting" id="sortLiveCheck"/>Sort Live Streams</div>
<div class="anOption" onclick="toggleList();"><input type="checkbox" name="listModeCheck" id="listModeCheck"/>List Mode</div>
</div>
<!--<div class="horizLabel"><span>COLOR</span></div>-->
<div id="colorsList">
<div class="colorLabel">Live Color: </div>
<div class="colorInput"><input class="jscolor" onchange="colorUpdate(this)" name="live" id="liveColor" value="008000"></div>
<div class="colorReset" onclick="colorReset('live')">Reset</div><br />
<div class="colorLabel">Offline Color: </div>
<div class="colorInput"><input class="jscolor" onchange="colorUpdate(this)" name="offline" id="offlineColor" value="FF0000"></div>
<div class="colorReset" onclick="colorReset('offline')">Reset</div><br />
<div class="colorLabel">Rerun Color: </div>
<div class="colorInput"><input class="jscolor" onchange="colorUpdate(this)" name="rerun" id="rerunColor" value="FFFF00"></div>
<div class="colorReset" onclick="colorReset('rerun')">Reset</div><br />
<div class="colorLabel">Error Color: </div>
<div class="colorInput"><input class="jscolor" onchange="colorUpdate(this)" name="info" id="infoColor" value="FFA500"></div>
<div class="colorReset" onclick="colorReset('info')">Reset</div>
</div>
</div>
</body>
</html>
